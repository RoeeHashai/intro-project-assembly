    // # Read the users guess
    // movq $scanf_fmt, %rdi
    // movq %rsp, %rsi
    // xorq %rax, %rax
    // call scanf

    // # Print the result
    // movq $result_fmt, %rdi
    // movq (%rsp), %rsi   # Load the value from the memory location pointed to by seed
    // xorq %rax, %rax
    // call printf

    // # Increment loop counter
    // incl %ecx

    // # Compare with the loop limit (5)
    // cmpl $5, %ecx
    // jl for_loop     # Jump to for_loop if ecx < 5

    // # Else - cleanup stack and exit the program
    // addq $4, %rsp
    // jmp exit_program



    # Print the result
    movq $result_fmt, %rdi
    movq [seed], %rsi   # Load the value from the memory location pointed to by seed
    xorq %rax, %rax
    call printf


    .loop:
    # Print the next guess prompt
    movq $user_guess_fmt, %rdi
    xorq %rax, %rax
    call printf
    jmp done
//     # Read the users guess
//     movq $scanf_fmt, %rdi
//     movq %rsp, %rsi
//     xorq %rax, %rax
//     call scanf

//     # Print the result
//     movq $result_fmt, %rdi
//     movq (%rsp), %rsi   # Load the value from the memory location pointed to by seed
//     xorq %rax, %rax
//     call printf

//     # Increment loop counter
//     incl %ecx

//     # Compare with the loop limit (5)
//     cmpl $5, %ecx
//     jl loop     # Jump to for_loop if ecx < 5

//     # Else - cleanup stack and exit the program
//     addq $4, %rsp
//     jmp done



.section .data
    seed:
        .space 4   # Allocate 4 bytes for the integer

.section .rodata
user_configSeed_fmt:
    .string "Enter configuration seed: "
scanf_fmt:
    .string "%d"
user_guess_fmt:
    .string "What is your guess? "
result_fmt:
    .string "Seed read: %d\n"

.section .text
.globl main
.type	main, @function

main:
    # Starting stack frame
    pushq %rbp
    movq %rsp, %rbp

    # Print the prompt
    movq $user_configSeed_fmt, %rdi
    xorq %rax, %rax
    call printf

    # Read the seed input
    movq $scanf_fmt, %rdi
    movq $seed, %rsi
    xorq %rax, %rax
    call scanf

    # Set the Seeds for srand
    movq $seed, %rdi
    call srand

    # Initialize loop counter
    movl $0, %ecx   # Counter register

    // # Starting stack frame
    // pushq %rbp
    // movq %rsp, %rbp
    subq $4, %rsp   # Allocate space for local variables (assuming 4 bytes)
    movq $1, (%rsp)

    # Print the result
    movq $result_fmt, %rdi
    movq (%rsp), %rsi  
    xorq %rax, %rax
    call printf

    addq $4, %rsp
    # Clean up the stack
    // movq %rbp, %rsp
    popq %rbp
    ret


// .loop:
//     # Print the prompt for guess
//     movq $user_guess_fmt, %rdi
//     xorq %rax, %rax
//     call printf

//     # Allocate space for the guess input on the stack
//     subq $4, %rsp  # Assuming userGuess is a 4-byte integer

//     # Read the guess input
//     movq $scanf_fmt, %rdi
//     movq %rsp, %rsi  # Load the address of userGuess on the stack
//     xorq %rax, %rax
//     call scanf
//     # Move the stack pointer 4 bytes back
//     addq $4, %rsp


//     // # Increment loop counter
//     // incl %ecx

//     // # Check if the loop counter is less than 5
//     // cmpl $5, %ecx
//     // jl .loop

// .done:
//     # Restore stack pointer
//     movq %rbp, %rsp

//     # Exit
//     xorq %rax, %rax
//     popq %rbp
//     ret




.section .rodata
user_configSeed_fmt:
    .string "Enter configuration seed: "
scanf_fmt:
    .string "%d"
result_fmt:
    .string "Seed read: %d\n"

.section .text
.globl main
.type main, @function

main:
    # Starting stack frame
    pushq %rbp
    movq %rsp, %rbp

    # Allocate space for the local variable (4 bytes assuming 32-bit integer)
    subq $16, %rsp

    # Print the prompt
    movq $user_configSeed_fmt, %rdi
    xorq %rax, %rax
    call printf

    # Read the seed input
    movq $scanf_fmt, %rdi
    leaq (%rsp), %rsi  # Load the address of the allocated space into rsi
    xorq %rax, %rax
    call scanf

    # Print the result
    movq $result_fmt, %rdi
    movl (%rsp), %esi  # Load the value of the seed into esi
    xorq %rax, %rax
    call printf

    # Clean up and exit
    movq %rbp, %rsp
    popq %rbp
    ret
